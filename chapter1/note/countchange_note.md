# 实例：换零钱的统计  
这个问题中作者的解决方法就是递归的解决方法。将大钞转换为小一点的面额的换零钱的方法。  
不断递归直到最小,即1元时，只有一种换零钱的方法。  
这里作者已经默认从最大到最小排序好了硬币。  

即当你有5种硬币时，肯定是有50,25,10,5,1  
当你有4种硬币时，肯定是有25,10,5,1  
....  
当你有一种硬币时，肯定是有1  

所以每次你都面临两种选择，一种是换掉自己最大面额的硬币，第二种是我要换更小面额的硬币。  
对应的代码是：
```
(+ (cc amount
             (- kinds-of-coins 1))
          (cc (- amount
                 (first-denomination kinds-of-coins))
              kinds-of-coins))
```
这样我们就生成了一颗递归树，每个节点生成另外的两个节点表示我们不同的两种选择。  

而这个函数：
```
(define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))
```
的作用是：  
当我们有5个硬币并调用这个函数（作第二种选择）时，我们换掉最大的面额50。即返回了50,然后执行了
```
(- amount
 (first-denomination kinds-of-coins))
```
代表从面额中减去50元
当我们有4个硬币并调用这个函数（作第二种选择）时，我们换掉最大的面额25。  
...
当我们有1个硬币并调用这个函数（作第二种选择）时，我们换掉最大的面额1。  

将每种情况下的两种选择所换硬币的方法相加，就是总的换硬币的方法。
